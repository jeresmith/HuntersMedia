{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\nimport findFocusedRoute from \"./findFocusedRoute\";\nimport validatePathConfig from \"./validatePathConfig\";\nexport default function getStateFromPath(path, options) {\n  var _ref;\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  var initialRoutes = [];\n\n  if (options !== null && options !== void 0 && options.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: []\n    });\n  }\n\n  var screens = options === null || options === void 0 ? void 0 : options.screens;\n  var remaining = path.replace(/\\/+/g, '/').replace(/^\\//, '').replace(/\\?.*$/, '');\n  remaining = remaining.endsWith('/') ? remaining : remaining + \"/\";\n\n  if (screens === undefined) {\n    var _routes = remaining.split('/').filter(Boolean).map(function (segment) {\n      var name = decodeURIComponent(segment);\n      return {\n        name: name\n      };\n    });\n\n    if (_routes.length) {\n      return createNestedStateObject(path, _routes, initialRoutes);\n    }\n\n    return undefined;\n  }\n\n  var configs = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.keys(screens).map(function (key) {\n    return createNormalizedConfigs(key, screens, [], initialRoutes, []);\n  }))).sort(function (a, b) {\n    if (a.pattern === b.pattern) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n\n    if (a.pattern.startsWith(b.pattern)) {\n      return -1;\n    }\n\n    if (b.pattern.startsWith(a.pattern)) {\n      return 1;\n    }\n\n    var aParts = a.pattern.split('/');\n    var bParts = b.pattern.split('/');\n\n    for (var i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n      if (aParts[i] == null) {\n        return 1;\n      }\n\n      if (bParts[i] == null) {\n        return -1;\n      }\n\n      var aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');\n      var bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');\n\n      if (aWildCard && bWildCard) {\n        continue;\n      }\n\n      if (aWildCard) {\n        return 1;\n      }\n\n      if (bWildCard) {\n        return -1;\n      }\n    }\n\n    return bParts.length - aParts.length;\n  });\n\n  configs.reduce(function (acc, config) {\n    if (acc[config.pattern]) {\n      var a = acc[config.pattern].routeNames;\n      var b = config.routeNames;\n      var intersects = a.length > b.length ? b.every(function (it, i) {\n        return a[i] === it;\n      }) : a.every(function (it, i) {\n        return b[i] === it;\n      });\n\n      if (!intersects) {\n        throw new Error(\"Found conflicting screens with the same pattern. The pattern '\" + config.pattern + \"' resolves to both '\" + a.join(' > ') + \"' and '\" + b.join(' > ') + \"'. Patterns must be unique and cannot resolve to more than one screen.\");\n      }\n    }\n\n    return _extends(acc, _defineProperty({}, config.pattern, config));\n  }, {});\n\n  if (remaining === '/') {\n    var match = configs.find(function (config) {\n      return config.path === '' && config.routeNames.every(function (name) {\n        var _configs$find;\n\n        return !((_configs$find = configs.find(function (c) {\n          return c.screen === name;\n        })) !== null && _configs$find !== void 0 && _configs$find.path);\n      });\n    });\n\n    if (match) {\n      return createNestedStateObject(path, match.routeNames.map(function (name) {\n        return {\n          name: name\n        };\n      }), initialRoutes, configs);\n    }\n\n    return undefined;\n  }\n\n  var result;\n  var current;\n\n  var _matchAgainstConfigs = matchAgainstConfigs(remaining, configs.map(function (c) {\n    return _objectSpread(_objectSpread({}, c), {}, {\n      regex: c.regex ? new RegExp(c.regex.source + '$') : undefined\n    });\n  })),\n      routes = _matchAgainstConfigs.routes,\n      remainingPath = _matchAgainstConfigs.remainingPath;\n\n  if (routes !== undefined) {\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\n    remaining = remainingPath;\n    result = current;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  return result;\n}\n\nvar joinPaths = function joinPaths() {\n  var _ref2;\n\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n\n  return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n};\n\nvar matchAgainstConfigs = function matchAgainstConfigs(remaining, configs) {\n  var routes;\n  var remainingPath = remaining;\n\n  var _loop = function _loop(config) {\n    if (!config.regex) {\n      return \"continue\";\n    }\n\n    var match = remainingPath.match(config.regex);\n\n    if (match) {\n      var matchedParams = (_config$pattern = config.pattern) === null || _config$pattern === void 0 ? void 0 : _config$pattern.split('/').filter(function (p) {\n        return p.startsWith(':');\n      }).reduce(function (acc, p, i) {\n        return _extends(acc, _defineProperty({}, p, match[(i + 1) * 2].replace(/\\//, '')));\n      }, {});\n      routes = config.routeNames.map(function (name) {\n        var _config$path;\n\n        var config = configs.find(function (c) {\n          return c.screen === name;\n        });\n        var params = config === null || config === void 0 ? void 0 : (_config$path = config.path) === null || _config$path === void 0 ? void 0 : _config$path.split('/').filter(function (p) {\n          return p.startsWith(':');\n        }).reduce(function (acc, p) {\n          var value = matchedParams[p];\n\n          if (value) {\n            var _config$parse;\n\n            var key = p.replace(/^:/, '').replace(/\\?$/, '');\n            acc[key] = (_config$parse = config.parse) !== null && _config$parse !== void 0 && _config$parse[key] ? config.parse[key](value) : value;\n          }\n\n          return acc;\n        }, {});\n\n        if (params && Object.keys(params).length) {\n          return {\n            name: name,\n            params: params\n          };\n        }\n\n        return {\n          name: name\n        };\n      });\n      remainingPath = remainingPath.replace(match[1], '');\n      return \"break\";\n    }\n  };\n\n  for (var _iterator = _createForOfIteratorHelperLoose(configs), _step; !(_step = _iterator()).done;) {\n    var config = _step.value;\n\n    var _config$pattern;\n\n    var _ret = _loop(config);\n\n    if (_ret === \"continue\") continue;\n    if (_ret === \"break\") break;\n  }\n\n  return {\n    routes: routes,\n    remainingPath: remainingPath\n  };\n};\n\nvar createNormalizedConfigs = function createNormalizedConfigs(screen, routeConfig) {\n  var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var initials = arguments.length > 3 ? arguments[3] : undefined;\n  var parentScreens = arguments.length > 4 ? arguments[4] : undefined;\n  var parentPattern = arguments.length > 5 ? arguments[5] : undefined;\n  var configs = [];\n  routeNames.push(screen);\n  parentScreens.push(screen);\n  var config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    var pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    configs.push(createConfigItem(screen, routeNames, pattern, config));\n  } else if (typeof config === 'object') {\n    var _pattern2;\n\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n      }\n\n      _pattern2 = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n      configs.push(createConfigItem(screen, routeNames, _pattern2, config.path, config.parse));\n    }\n\n    if (config.screens) {\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens: parentScreens\n        });\n      }\n\n      Object.keys(config.screens).forEach(function (nestedConfig) {\n        var _pattern;\n\n        var result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, _toConsumableArray(parentScreens), (_pattern = _pattern2) !== null && _pattern !== void 0 ? _pattern : parentPattern);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n\n  routeNames.pop();\n  return configs;\n};\n\nvar createConfigItem = function createConfigItem(screen, routeNames, pattern, path, parse) {\n  pattern = pattern.split('/').filter(Boolean).join('/');\n  var regex = pattern ? new RegExp(\"^(\" + pattern.split('/').map(function (it) {\n    if (it.startsWith(':')) {\n      return \"(([^/]+\\\\/)\" + (it.endsWith('?') ? '?' : '') + \")\";\n    }\n\n    return (it === '*' ? '.*' : escape(it)) + \"\\\\/\";\n  }).join('') + \")\") : undefined;\n  return {\n    screen: screen,\n    regex: regex,\n    pattern: pattern,\n    path: path,\n    routeNames: _toConsumableArray(routeNames),\n    parse: parse\n  };\n};\n\nvar findParseConfigForRoute = function findParseConfigForRoute(routeName, flatConfig) {\n  for (var _iterator2 = _createForOfIteratorHelperLoose(flatConfig), _step2; !(_step2 = _iterator2()).done;) {\n    var config = _step2.value;\n\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\nvar findInitialRoute = function findInitialRoute(routeName, parentScreens, initialRoutes) {\n  for (var _iterator3 = _createForOfIteratorHelperLoose(initialRoutes), _step3; !(_step3 = _iterator3()).done;) {\n    var config = _step3.value;\n\n    if (parentScreens.length === config.parentScreens.length) {\n      var sameParents = true;\n\n      for (var i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n\n      if (sameParents) {\n        return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nvar createStateObject = function createStateObject(initialRoute, route, isEmpty) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, route]\n      };\n    } else {\n      return {\n        routes: [route]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, _objectSpread(_objectSpread({}, route), {}, {\n          state: {\n            routes: []\n          }\n        })]\n      };\n    } else {\n      return {\n        routes: [_objectSpread(_objectSpread({}, route), {}, {\n          state: {\n            routes: []\n          }\n        })]\n      };\n    }\n  }\n};\n\nvar createNestedStateObject = function createNestedStateObject(path, routes, initialRoutes, flatConfig) {\n  var state;\n  var route = routes.shift();\n  var parentScreens = [];\n  var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n  parentScreens.push(route.name);\n  state = createStateObject(initialRoute, route, routes.length === 0);\n\n  if (routes.length > 0) {\n    var nestedState = state;\n\n    while (route = routes.shift()) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n      var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n      nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state);\n  route.path = path;\n  var params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);\n\n  if (params) {\n    route.params = _objectSpread(_objectSpread({}, route.params), params);\n  }\n\n  return state;\n};\n\nvar parseQueryParams = function parseQueryParams(path, parseConfig) {\n  var query = path.split('?')[1];\n  var params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach(function (name) {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};","map":{"version":3,"mappings":"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","names":["escape","queryString","findFocusedRoute","validatePathConfig","getStateFromPath","path","options","initialRoutes","initialRouteName","push","parentScreens","screens","remaining","replace","endsWith","undefined","routes","split","filter","Boolean","map","name","decodeURIComponent","segment","length","createNestedStateObject","configs","concat","Object","keys","createNormalizedConfigs","key","sort","a","b","pattern","routeNames","join","localeCompare","startsWith","aParts","bParts","i","Math","max","aWildCard","bWildCard","reduce","acc","config","intersects","every","it","Error","match","find","_configs$find","c","screen","result","current","matchAgainstConfigs","regex","RegExp","source","remainingPath","joinPaths","_len","arguments","paths","Array","_key","p","matchedParams","_config$pattern","_config$path","params","value","_config$parse","parse","routeConfig","initials","parentPattern","createConfigItem","exact","forEach","_pattern","nestedConfig","pop","findParseConfigForRoute","routeName","flatConfig","findInitialRoute","sameParents","createStateObject","initialRoute","route","isEmpty","index","state","shift","nestedState","nestedStateIndex","parseQueryParams","parseConfig","query"],"sources":["C:/Users/lance/OneDrive/Documents/GitHub/HuntersMedia/code/node_modules/@react-navigation/core/lib/module/getStateFromPath.js"],"sourcesContent":["import escape from 'escape-string-regexp';\r\nimport * as queryString from 'query-string';\r\nimport findFocusedRoute from './findFocusedRoute';\r\nimport validatePathConfig from './validatePathConfig';\r\n\r\n/**\r\n * Utility to parse a path string to initial state object accepted by the container.\r\n * This is useful for deep linking when we need to handle the incoming URL.\r\n *\r\n * @example\r\n * ```js\r\n * getStateFromPath(\r\n *   '/chat/jane/42',\r\n *   {\r\n *     screens: {\r\n *       Chat: {\r\n *         path: 'chat/:author/:id',\r\n *         parse: { id: Number }\r\n *       }\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\r\n * @param options Extra options to fine-tune how to parse the path.\r\n */\r\nexport default function getStateFromPath(path, options) {\r\n  if (options) {\r\n    validatePathConfig(options);\r\n  }\r\n\r\n  let initialRoutes = [];\r\n\r\n  if (options !== null && options !== void 0 && options.initialRouteName) {\r\n    initialRoutes.push({\r\n      initialRouteName: options.initialRouteName,\r\n      parentScreens: []\r\n    });\r\n  }\r\n\r\n  const screens = options === null || options === void 0 ? void 0 : options.screens;\r\n  let remaining = path.replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\r\n  .replace(/^\\//, '') // Remove extra leading slash\r\n  .replace(/\\?.*$/, ''); // Remove query params which we will handle later\r\n  // Make sure there is a trailing slash\r\n\r\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\r\n\r\n  if (screens === undefined) {\r\n    // When no config is specified, use the path segments as route names\r\n    const routes = remaining.split('/').filter(Boolean).map(segment => {\r\n      const name = decodeURIComponent(segment);\r\n      return {\r\n        name\r\n      };\r\n    });\r\n\r\n    if (routes.length) {\r\n      return createNestedStateObject(path, routes, initialRoutes);\r\n    }\r\n\r\n    return undefined;\r\n  } // Create a normalized configs array which will be easier to use\r\n\r\n\r\n  const configs = [].concat(...Object.keys(screens).map(key => createNormalizedConfigs(key, screens, [], initialRoutes, []))).sort((a, b) => {\r\n    // Sort config so that:\r\n    // - the most exhaustive ones are always at the beginning\r\n    // - patterns with wildcard are always at the end\r\n    // If 2 patterns are same, move the one with less route names up\r\n    // This is an error state, so it's only useful for consistent error messages\r\n    if (a.pattern === b.pattern) {\r\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\r\n    } // If one of the patterns starts with the other, it's more exhaustive\r\n    // So move it up\r\n\r\n\r\n    if (a.pattern.startsWith(b.pattern)) {\r\n      return -1;\r\n    }\r\n\r\n    if (b.pattern.startsWith(a.pattern)) {\r\n      return 1;\r\n    }\r\n\r\n    const aParts = a.pattern.split('/');\r\n    const bParts = b.pattern.split('/');\r\n\r\n    for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\r\n      // if b is longer, b get higher priority\r\n      if (aParts[i] == null) {\r\n        return 1;\r\n      } // if a is longer, a get higher priority\r\n\r\n\r\n      if (bParts[i] == null) {\r\n        return -1;\r\n      }\r\n\r\n      const aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');\r\n      const bWildCard = bParts[i] === '*' || bParts[i].startsWith(':'); // if both are wildcard we compare next component\r\n\r\n      if (aWildCard && bWildCard) {\r\n        continue;\r\n      } // if only a is wild card, b get higher priority\r\n\r\n\r\n      if (aWildCard) {\r\n        return 1;\r\n      } // if only b is wild card, a get higher priority\r\n\r\n\r\n      if (bWildCard) {\r\n        return -1;\r\n      }\r\n    }\r\n\r\n    return bParts.length - aParts.length;\r\n  }); // Check for duplicate patterns in the config\r\n\r\n  configs.reduce((acc, config) => {\r\n    if (acc[config.pattern]) {\r\n      const a = acc[config.pattern].routeNames;\r\n      const b = config.routeNames; // It's not a problem if the path string omitted from a inner most screen\r\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\r\n\r\n      const intersects = a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);\r\n\r\n      if (!intersects) {\r\n        throw new Error(`Found conflicting screens with the same pattern. The pattern '${config.pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);\r\n      }\r\n    }\r\n\r\n    return Object.assign(acc, {\r\n      [config.pattern]: config\r\n    });\r\n  }, {});\r\n\r\n  if (remaining === '/') {\r\n    // We need to add special handling of empty path so navigation to empty path also works\r\n    // When handling empty path, we should only look at the root level config\r\n    const match = configs.find(config => config.path === '' && config.routeNames.every( // Make sure that none of the parent configs have a non-empty path defined\r\n    name => {\r\n      var _configs$find;\r\n\r\n      return !((_configs$find = configs.find(c => c.screen === name)) !== null && _configs$find !== void 0 && _configs$find.path);\r\n    }));\r\n\r\n    if (match) {\r\n      return createNestedStateObject(path, match.routeNames.map(name => ({\r\n        name\r\n      })), initialRoutes, configs);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  let result;\r\n  let current; // We match the whole path against the regex instead of segments\r\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\r\n\r\n  const {\r\n    routes,\r\n    remainingPath\r\n  } = matchAgainstConfigs(remaining, configs.map(c => ({ ...c,\r\n    // Add `$` to the regex to make sure it matches till end of the path and not just beginning\r\n    regex: c.regex ? new RegExp(c.regex.source + '$') : undefined\r\n  })));\r\n\r\n  if (routes !== undefined) {\r\n    // This will always be empty if full path matched\r\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\r\n    remaining = remainingPath;\r\n    result = current;\r\n  }\r\n\r\n  if (current == null || result == null) {\r\n    return undefined;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst joinPaths = function () {\r\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\r\n    paths[_key] = arguments[_key];\r\n  }\r\n\r\n  return [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');\r\n};\r\n\r\nconst matchAgainstConfigs = (remaining, configs) => {\r\n  let routes;\r\n  let remainingPath = remaining; // Go through all configs, and see if the next path segment matches our regex\r\n\r\n  for (const config of configs) {\r\n    if (!config.regex) {\r\n      continue;\r\n    }\r\n\r\n    const match = remainingPath.match(config.regex); // If our regex matches, we need to extract params from the path\r\n\r\n    if (match) {\r\n      var _config$pattern;\r\n\r\n      const matchedParams = (_config$pattern = config.pattern) === null || _config$pattern === void 0 ? void 0 : _config$pattern.split('/').filter(p => p.startsWith(':')).reduce((acc, p, i) => Object.assign(acc, {\r\n        // The param segments appear every second item starting from 2 in the regex match result\r\n        [p]: match[(i + 1) * 2].replace(/\\//, '')\r\n      }), {});\r\n      routes = config.routeNames.map(name => {\r\n        var _config$path;\r\n\r\n        const config = configs.find(c => c.screen === name);\r\n        const params = config === null || config === void 0 ? void 0 : (_config$path = config.path) === null || _config$path === void 0 ? void 0 : _config$path.split('/').filter(p => p.startsWith(':')).reduce((acc, p) => {\r\n          const value = matchedParams[p];\r\n\r\n          if (value) {\r\n            var _config$parse;\r\n\r\n            const key = p.replace(/^:/, '').replace(/\\?$/, '');\r\n            acc[key] = (_config$parse = config.parse) !== null && _config$parse !== void 0 && _config$parse[key] ? config.parse[key](value) : value;\r\n          }\r\n\r\n          return acc;\r\n        }, {});\r\n\r\n        if (params && Object.keys(params).length) {\r\n          return {\r\n            name,\r\n            params\r\n          };\r\n        }\r\n\r\n        return {\r\n          name\r\n        };\r\n      });\r\n      remainingPath = remainingPath.replace(match[1], '');\r\n      break;\r\n    }\r\n  }\r\n\r\n  return {\r\n    routes,\r\n    remainingPath\r\n  };\r\n};\r\n\r\nconst createNormalizedConfigs = function (screen, routeConfig) {\r\n  let routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\r\n  let initials = arguments.length > 3 ? arguments[3] : undefined;\r\n  let parentScreens = arguments.length > 4 ? arguments[4] : undefined;\r\n  let parentPattern = arguments.length > 5 ? arguments[5] : undefined;\r\n  const configs = [];\r\n  routeNames.push(screen);\r\n  parentScreens.push(screen); // @ts-expect-error: we can't strongly typecheck this for now\r\n\r\n  const config = routeConfig[screen];\r\n\r\n  if (typeof config === 'string') {\r\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\r\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\r\n    configs.push(createConfigItem(screen, routeNames, pattern, config));\r\n  } else if (typeof config === 'object') {\r\n    let pattern; // if an object is specified as the value (e.g. Foo: { ... }),\r\n    // it can have `path` property and\r\n    // it could have `screens` prop which has nested configs\r\n\r\n    if (typeof config.path === 'string') {\r\n      if (config.exact && config.path === undefined) {\r\n        throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\r\n      }\r\n\r\n      pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\r\n      configs.push(createConfigItem(screen, routeNames, pattern, config.path, config.parse));\r\n    }\r\n\r\n    if (config.screens) {\r\n      // property `initialRouteName` without `screens` has no purpose\r\n      if (config.initialRouteName) {\r\n        initials.push({\r\n          initialRouteName: config.initialRouteName,\r\n          parentScreens\r\n        });\r\n      }\r\n\r\n      Object.keys(config.screens).forEach(nestedConfig => {\r\n        var _pattern;\r\n\r\n        const result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, [...parentScreens], (_pattern = pattern) !== null && _pattern !== void 0 ? _pattern : parentPattern);\r\n        configs.push(...result);\r\n      });\r\n    }\r\n  }\r\n\r\n  routeNames.pop();\r\n  return configs;\r\n};\r\n\r\nconst createConfigItem = (screen, routeNames, pattern, path, parse) => {\r\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\r\n  pattern = pattern.split('/').filter(Boolean).join('/');\r\n  const regex = pattern ? new RegExp(`^(${pattern.split('/').map(it => {\r\n    if (it.startsWith(':')) {\r\n      return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\r\n    }\r\n\r\n    return `${it === '*' ? '.*' : escape(it)}\\\\/`;\r\n  }).join('')})`) : undefined;\r\n  return {\r\n    screen,\r\n    regex,\r\n    pattern,\r\n    path,\r\n    // The routeNames array is mutated, so copy it to keep the current state\r\n    routeNames: [...routeNames],\r\n    parse\r\n  };\r\n};\r\n\r\nconst findParseConfigForRoute = (routeName, flatConfig) => {\r\n  for (const config of flatConfig) {\r\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\r\n      return config.parse;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}; // Try to find an initial route connected with the one passed\r\n\r\n\r\nconst findInitialRoute = (routeName, parentScreens, initialRoutes) => {\r\n  for (const config of initialRoutes) {\r\n    if (parentScreens.length === config.parentScreens.length) {\r\n      let sameParents = true;\r\n\r\n      for (let i = 0; i < parentScreens.length; i++) {\r\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\r\n          sameParents = false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (sameParents) {\r\n        return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\r\n      }\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}; // returns state object with values depending on whether\r\n// it is the end of state and if there is initialRoute for this level\r\n\r\n\r\nconst createStateObject = (initialRoute, route, isEmpty) => {\r\n  if (isEmpty) {\r\n    if (initialRoute) {\r\n      return {\r\n        index: 1,\r\n        routes: [{\r\n          name: initialRoute\r\n        }, route]\r\n      };\r\n    } else {\r\n      return {\r\n        routes: [route]\r\n      };\r\n    }\r\n  } else {\r\n    if (initialRoute) {\r\n      return {\r\n        index: 1,\r\n        routes: [{\r\n          name: initialRoute\r\n        }, { ...route,\r\n          state: {\r\n            routes: []\r\n          }\r\n        }]\r\n      };\r\n    } else {\r\n      return {\r\n        routes: [{ ...route,\r\n          state: {\r\n            routes: []\r\n          }\r\n        }]\r\n      };\r\n    }\r\n  }\r\n};\r\n\r\nconst createNestedStateObject = (path, routes, initialRoutes, flatConfig) => {\r\n  let state;\r\n  let route = routes.shift();\r\n  const parentScreens = [];\r\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\r\n  parentScreens.push(route.name);\r\n  state = createStateObject(initialRoute, route, routes.length === 0);\r\n\r\n  if (routes.length > 0) {\r\n    let nestedState = state;\r\n\r\n    while (route = routes.shift()) {\r\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\r\n      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\r\n      nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);\r\n\r\n      if (routes.length > 0) {\r\n        nestedState = nestedState.routes[nestedStateIndex].state;\r\n      }\r\n\r\n      parentScreens.push(route.name);\r\n    }\r\n  }\r\n\r\n  route = findFocusedRoute(state);\r\n  route.path = path;\r\n  const params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);\r\n\r\n  if (params) {\r\n    route.params = { ...route.params,\r\n      ...params\r\n    };\r\n  }\r\n\r\n  return state;\r\n};\r\n\r\nconst parseQueryParams = (path, parseConfig) => {\r\n  const query = path.split('?')[1];\r\n  const params = queryString.parse(query);\r\n\r\n  if (parseConfig) {\r\n    Object.keys(params).forEach(name => {\r\n      if (parseConfig[name] && typeof params[name] === 'string') {\r\n        params[name] = parseConfig[name](params[name]);\r\n      }\r\n    });\r\n  }\r\n\r\n  return Object.keys(params).length ? params : undefined;\r\n};\r\n//# sourceMappingURL=getStateFromPath.js.map"]},"metadata":{},"sourceType":"module"}