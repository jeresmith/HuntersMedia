{"ast":null,"code":"import _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { Background, getDefaultHeaderHeight, SafeAreaProviderCompat } from '@react-navigation/elements';\nimport Color from 'color';\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport { forModalPresentationIOS, forNoAnimation as forNoAnimationCard } from \"../../TransitionConfigs/CardStyleInterpolators\";\nimport { DefaultTransition, ModalFadeTransition, ModalTransition } from \"../../TransitionConfigs/TransitionPresets\";\nimport getDistanceForDirection from \"../../utils/getDistanceForDirection\";\nimport { MaybeScreen, MaybeScreenContainer } from \"../Screens\";\nimport { getIsModalPresentation } from \"./Card\";\nimport CardContainer from \"./CardContainer\";\nvar EPSILON = 0.01;\nvar STATE_INACTIVE = 0;\nvar STATE_TRANSITIONING_OR_BELOW_TOP = 1;\nvar STATE_ON_TOP = 2;\nvar FALLBACK_DESCRIPTOR = Object.freeze({\n  options: {}\n});\n\nvar getInterpolationIndex = function getInterpolationIndex(scenes, index) {\n  var cardStyleInterpolator = scenes[index].descriptor.options.cardStyleInterpolator;\n  var interpolationIndex = 0;\n\n  for (var i = index - 1; i >= 0; i--) {\n    var _scenes$i;\n\n    var cardStyleInterpolatorCurrent = (_scenes$i = scenes[i]) === null || _scenes$i === void 0 ? void 0 : _scenes$i.descriptor.options.cardStyleInterpolator;\n\n    if (cardStyleInterpolatorCurrent !== cardStyleInterpolator) {\n      break;\n    }\n\n    interpolationIndex++;\n  }\n\n  return interpolationIndex;\n};\n\nvar getIsModal = function getIsModal(scene, interpolationIndex, isParentModal) {\n  if (isParentModal) {\n    return true;\n  }\n\n  var cardStyleInterpolator = scene.descriptor.options.cardStyleInterpolator;\n  var isModalPresentation = getIsModalPresentation(cardStyleInterpolator);\n  var isModal = isModalPresentation && interpolationIndex !== 0;\n  return isModal;\n};\n\nvar getHeaderHeights = function getHeaderHeights(scenes, insets, isParentHeaderShown, isParentModal, layout, previous) {\n  return scenes.reduce(function (acc, curr, index) {\n    var _curr$descriptor$opti = curr.descriptor.options,\n        _curr$descriptor$opti2 = _curr$descriptor$opti.headerStatusBarHeight,\n        headerStatusBarHeight = _curr$descriptor$opti2 === void 0 ? isParentHeaderShown ? 0 : insets.top : _curr$descriptor$opti2,\n        headerStyle = _curr$descriptor$opti.headerStyle;\n    var style = StyleSheet.flatten(headerStyle || {});\n    var height = typeof style.height === 'number' ? style.height : previous[curr.route.key];\n    var interpolationIndex = getInterpolationIndex(scenes, index);\n    var isModal = getIsModal(curr, interpolationIndex, isParentModal);\n    acc[curr.route.key] = typeof height === 'number' ? height : getDefaultHeaderHeight(layout, isModal, headerStatusBarHeight);\n    return acc;\n  }, {});\n};\n\nvar getDistanceFromOptions = function getDistanceFromOptions(layout, descriptor) {\n  var _ref4 = (descriptor === null || descriptor === void 0 ? void 0 : descriptor.options) || {},\n      presentation = _ref4.presentation,\n      _ref4$gestureDirectio = _ref4.gestureDirection,\n      gestureDirection = _ref4$gestureDirectio === void 0 ? presentation === 'modal' ? ModalTransition.gestureDirection : DefaultTransition.gestureDirection : _ref4$gestureDirectio;\n\n  return getDistanceForDirection(layout, gestureDirection);\n};\n\nvar getProgressFromGesture = function getProgressFromGesture(gesture, layout, descriptor) {\n  var distance = getDistanceFromOptions({\n    width: Math.max(1, layout.width),\n    height: Math.max(1, layout.height)\n  }, descriptor);\n\n  if (distance > 0) {\n    return gesture.interpolate({\n      inputRange: [0, distance],\n      outputRange: [1, 0]\n    });\n  }\n\n  return gesture.interpolate({\n    inputRange: [distance, 0],\n    outputRange: [0, 1]\n  });\n};\n\nvar CardStack = function (_React$Component) {\n  _inherits(CardStack, _React$Component);\n\n  var _super = _createSuper(CardStack);\n\n  function CardStack(_props) {\n    var _this;\n\n    _classCallCheck(this, CardStack);\n\n    _this = _super.call(this, _props);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleLayout\", function (e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n          height = _e$nativeEvent$layout.height,\n          width = _e$nativeEvent$layout.width;\n      var layout = {\n        width: width,\n        height: height\n      };\n\n      _this.setState(function (state, props) {\n        if (height === state.layout.height && width === state.layout.width) {\n          return null;\n        }\n\n        return {\n          layout: layout,\n          headerHeights: getHeaderHeights(state.scenes, props.insets, props.isParentHeaderShown, props.isParentModal, layout, state.headerHeights)\n        };\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleHeaderLayout\", function (_ref) {\n      var route = _ref.route,\n          height = _ref.height;\n\n      _this.setState(function (_ref2) {\n        var headerHeights = _ref2.headerHeights;\n        var previousHeight = headerHeights[route.key];\n\n        if (previousHeight === height) {\n          return null;\n        }\n\n        return {\n          headerHeights: _objectSpread(_objectSpread({}, headerHeights), {}, _defineProperty2({}, route.key, height))\n        };\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getFocusedRoute\", function () {\n      var state = _this.props.state;\n      return state.routes[state.index];\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getPreviousScene\", function (_ref3) {\n      var route = _ref3.route;\n      var getPreviousRoute = _this.props.getPreviousRoute;\n      var scenes = _this.state.scenes;\n      var previousRoute = getPreviousRoute({\n        route: route\n      });\n\n      if (previousRoute) {\n        var previousScene = scenes.find(function (scene) {\n          return scene.descriptor.route.key === previousRoute.key;\n        });\n        return previousScene;\n      }\n\n      return undefined;\n    });\n\n    _this.state = {\n      routes: [],\n      scenes: [],\n      gestures: {},\n      layout: SafeAreaProviderCompat.initialMetrics.frame,\n      descriptors: _this.props.descriptors,\n      headerHeights: {}\n    };\n    return _this;\n  }\n\n  _createClass(CardStack, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          insets = _this$props.insets,\n          state = _this$props.state,\n          routes = _this$props.routes,\n          closingRouteKeys = _this$props.closingRouteKeys,\n          onOpenRoute = _this$props.onOpenRoute,\n          onCloseRoute = _this$props.onCloseRoute,\n          renderHeader = _this$props.renderHeader,\n          renderScene = _this$props.renderScene,\n          isParentHeaderShown = _this$props.isParentHeaderShown,\n          isParentModal = _this$props.isParentModal,\n          onTransitionStart = _this$props.onTransitionStart,\n          onTransitionEnd = _this$props.onTransitionEnd,\n          onGestureStart = _this$props.onGestureStart,\n          onGestureEnd = _this$props.onGestureEnd,\n          onGestureCancel = _this$props.onGestureCancel,\n          _this$props$detachIna = _this$props.detachInactiveScreens,\n          detachInactiveScreens = _this$props$detachIna === void 0 ? Platform.OS === 'web' || Platform.OS === 'android' || Platform.OS === 'ios' : _this$props$detachIna;\n      var _this$state = this.state,\n          scenes = _this$state.scenes,\n          layout = _this$state.layout,\n          gestures = _this$state.gestures,\n          headerHeights = _this$state.headerHeights;\n      var focusedRoute = state.routes[state.index];\n      var focusedHeaderHeight = headerHeights[focusedRoute.key];\n      var isFloatHeaderAbsolute = this.state.scenes.slice(-2).some(function (scene) {\n        var _scene$descriptor$opt;\n\n        var options = (_scene$descriptor$opt = scene.descriptor.options) !== null && _scene$descriptor$opt !== void 0 ? _scene$descriptor$opt : {};\n        var headerMode = options.headerMode,\n            headerTransparent = options.headerTransparent,\n            _options$headerShown = options.headerShown,\n            headerShown = _options$headerShown === void 0 ? true : _options$headerShown;\n\n        if (headerTransparent || headerShown === false || headerMode === 'screen') {\n          return true;\n        }\n\n        return false;\n      });\n      var activeScreensLimit = 1;\n\n      for (var i = scenes.length - 1; i >= 0; i--) {\n        var options = scenes[i].descriptor.options;\n        var _options$detachPrevio = options.detachPreviousScreen,\n            detachPreviousScreen = _options$detachPrevio === void 0 ? options.presentation === 'transparentModal' ? false : getIsModalPresentation(options.cardStyleInterpolator) ? i !== scenes.map(function (scene) {\n          return scene.descriptor.options.cardStyleInterpolator;\n        }).lastIndexOf(forModalPresentationIOS) : true : _options$detachPrevio;\n\n        if (detachPreviousScreen === false) {\n          activeScreensLimit++;\n        } else {\n          if (i <= scenes.length - 2) {\n            break;\n          }\n        }\n      }\n\n      var floatingHeader = React.createElement(React.Fragment, {\n        key: \"header\"\n      }, renderHeader({\n        mode: 'float',\n        layout: layout,\n        scenes: scenes,\n        getPreviousScene: this.getPreviousScene,\n        getFocusedRoute: this.getFocusedRoute,\n        onContentHeightChange: this.handleHeaderLayout,\n        style: [styles.floating, isFloatHeaderAbsolute && [{\n          height: focusedHeaderHeight\n        }, styles.absolute]]\n      }));\n      return React.createElement(Background, null, isFloatHeaderAbsolute ? null : floatingHeader, React.createElement(MaybeScreenContainer, {\n        enabled: detachInactiveScreens,\n        style: styles.container,\n        onLayout: this.handleLayout\n      }, routes.map(function (route, index, self) {\n        var _scenes, _scenes2;\n\n        var focused = focusedRoute.key === route.key;\n        var gesture = gestures[route.key];\n        var scene = scenes[index];\n        var isScreenActive = 1;\n\n        if (index < self.length - activeScreensLimit - 1) {\n          isScreenActive = STATE_INACTIVE;\n        } else {\n          var sceneForActivity = scenes[self.length - 1];\n          var outputValue = index === self.length - 1 ? STATE_ON_TOP : index >= self.length - activeScreensLimit ? STATE_TRANSITIONING_OR_BELOW_TOP : STATE_INACTIVE;\n          isScreenActive = sceneForActivity ? sceneForActivity.progress.current.interpolate({\n            inputRange: [0, 1 - EPSILON, 1],\n            outputRange: [1, 1, outputValue],\n            extrapolate: 'clamp'\n          }) : STATE_TRANSITIONING_OR_BELOW_TOP;\n        }\n\n        var _scene$descriptor$opt2 = scene.descriptor.options,\n            _scene$descriptor$opt3 = _scene$descriptor$opt2.headerShown,\n            headerShown = _scene$descriptor$opt3 === void 0 ? true : _scene$descriptor$opt3,\n            headerTransparent = _scene$descriptor$opt2.headerTransparent,\n            headerStyle = _scene$descriptor$opt2.headerStyle,\n            headerTintColor = _scene$descriptor$opt2.headerTintColor;\n        var safeAreaInsetTop = insets.top;\n        var safeAreaInsetRight = insets.right;\n        var safeAreaInsetBottom = insets.bottom;\n        var safeAreaInsetLeft = insets.left;\n        var headerHeight = headerShown !== false ? headerHeights[route.key] : 0;\n\n        var _ref5 = StyleSheet.flatten(headerStyle) || {},\n            headerBackgroundColor = _ref5.backgroundColor;\n\n        var headerDarkContent;\n\n        if (headerShown) {\n          if (typeof headerTintColor === 'string') {\n            headerDarkContent = Color(headerTintColor).isDark();\n          } else if (typeof headerBackgroundColor === 'string') {\n            headerDarkContent = !Color(headerBackgroundColor).isDark();\n          }\n        }\n\n        var interpolationIndex = getInterpolationIndex(scenes, index);\n        var isModal = getIsModal(scene, interpolationIndex, isParentModal);\n        var isNextScreenTransparent = ((_scenes = scenes[index + 1]) === null || _scenes === void 0 ? void 0 : _scenes.descriptor.options.presentation) === 'transparentModal';\n        var detachCurrentScreen = ((_scenes2 = scenes[index + 1]) === null || _scenes2 === void 0 ? void 0 : _scenes2.descriptor.options.detachPreviousScreen) !== false;\n        return React.createElement(MaybeScreen, {\n          key: route.key,\n          style: StyleSheet.absoluteFill,\n          enabled: detachInactiveScreens,\n          active: isScreenActive,\n          pointerEvents: \"box-none\"\n        }, React.createElement(CardContainer, {\n          index: index,\n          interpolationIndex: interpolationIndex,\n          modal: isModal,\n          active: index === self.length - 1,\n          focused: focused,\n          closing: closingRouteKeys.includes(route.key),\n          layout: layout,\n          gesture: gesture,\n          scene: scene,\n          safeAreaInsetTop: safeAreaInsetTop,\n          safeAreaInsetRight: safeAreaInsetRight,\n          safeAreaInsetBottom: safeAreaInsetBottom,\n          safeAreaInsetLeft: safeAreaInsetLeft,\n          onGestureStart: onGestureStart,\n          onGestureCancel: onGestureCancel,\n          onGestureEnd: onGestureEnd,\n          headerHeight: headerHeight,\n          isParentHeaderShown: isParentHeaderShown,\n          onHeaderHeightChange: _this2.handleHeaderLayout,\n          getPreviousScene: _this2.getPreviousScene,\n          getFocusedRoute: _this2.getFocusedRoute,\n          headerDarkContent: headerDarkContent,\n          hasAbsoluteFloatHeader: isFloatHeaderAbsolute && !headerTransparent,\n          renderHeader: renderHeader,\n          renderScene: renderScene,\n          onOpenRoute: onOpenRoute,\n          onCloseRoute: onCloseRoute,\n          onTransitionStart: onTransitionStart,\n          onTransitionEnd: onTransitionEnd,\n          isNextScreenTransparent: isNextScreenTransparent,\n          detachCurrentScreen: detachCurrentScreen\n        }));\n      })), isFloatHeaderAbsolute ? floatingHeader : null);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      if (props.routes === state.routes && props.descriptors === state.descriptors) {\n        return null;\n      }\n\n      var gestures = props.routes.reduce(function (acc, curr) {\n        var descriptor = props.descriptors[curr.key];\n\n        var _ref6 = (descriptor === null || descriptor === void 0 ? void 0 : descriptor.options) || {},\n            animationEnabled = _ref6.animationEnabled;\n\n        acc[curr.key] = state.gestures[curr.key] || new Animated.Value(props.openingRouteKeys.includes(curr.key) && animationEnabled !== false ? getDistanceFromOptions(state.layout, descriptor) : 0);\n        return acc;\n      }, {});\n      var scenes = props.routes.map(function (route, index, self) {\n        var _descriptor$options$h;\n\n        var previousRoute = self[index - 1];\n        var nextRoute = self[index + 1];\n        var oldScene = state.scenes[index];\n        var currentGesture = gestures[route.key];\n        var previousGesture = previousRoute ? gestures[previousRoute.key] : undefined;\n        var nextGesture = nextRoute ? gestures[nextRoute.key] : undefined;\n        var descriptor = props.descriptors[route.key] || state.descriptors[route.key] || (oldScene ? oldScene.descriptor : FALLBACK_DESCRIPTOR);\n        var nextDescriptor = props.descriptors[nextRoute === null || nextRoute === void 0 ? void 0 : nextRoute.key] || state.descriptors[nextRoute === null || nextRoute === void 0 ? void 0 : nextRoute.key];\n        var previousDescriptor = props.descriptors[previousRoute === null || previousRoute === void 0 ? void 0 : previousRoute.key] || state.descriptors[previousRoute === null || previousRoute === void 0 ? void 0 : previousRoute.key];\n        var optionsForTransitionConfig = index !== self.length - 1 && nextDescriptor && nextDescriptor.options.presentation !== 'transparentModal' ? nextDescriptor.options : descriptor.options;\n        var defaultTransitionPreset = optionsForTransitionConfig.presentation === 'modal' ? ModalTransition : optionsForTransitionConfig.presentation === 'transparentModal' ? ModalFadeTransition : DefaultTransition;\n        var _optionsForTransition = optionsForTransitionConfig.animationEnabled,\n            animationEnabled = _optionsForTransition === void 0 ? Platform.OS !== 'web' && Platform.OS !== 'windows' && Platform.OS !== 'macos' : _optionsForTransition,\n            _optionsForTransition2 = optionsForTransitionConfig.gestureEnabled,\n            gestureEnabled = _optionsForTransition2 === void 0 ? Platform.OS === 'ios' && animationEnabled : _optionsForTransition2,\n            _optionsForTransition3 = optionsForTransitionConfig.gestureDirection,\n            gestureDirection = _optionsForTransition3 === void 0 ? defaultTransitionPreset.gestureDirection : _optionsForTransition3,\n            _optionsForTransition4 = optionsForTransitionConfig.transitionSpec,\n            transitionSpec = _optionsForTransition4 === void 0 ? defaultTransitionPreset.transitionSpec : _optionsForTransition4,\n            _optionsForTransition5 = optionsForTransitionConfig.cardStyleInterpolator,\n            cardStyleInterpolator = _optionsForTransition5 === void 0 ? animationEnabled === false ? forNoAnimationCard : defaultTransitionPreset.cardStyleInterpolator : _optionsForTransition5,\n            _optionsForTransition6 = optionsForTransitionConfig.headerStyleInterpolator,\n            headerStyleInterpolator = _optionsForTransition6 === void 0 ? defaultTransitionPreset.headerStyleInterpolator : _optionsForTransition6,\n            _optionsForTransition7 = optionsForTransitionConfig.cardOverlayEnabled,\n            cardOverlayEnabled = _optionsForTransition7 === void 0 ? Platform.OS !== 'ios' && optionsForTransitionConfig.presentation !== 'transparentModal' || getIsModalPresentation(cardStyleInterpolator) : _optionsForTransition7;\n        var headerMode = (_descriptor$options$h = descriptor.options.headerMode) !== null && _descriptor$options$h !== void 0 ? _descriptor$options$h : !(optionsForTransitionConfig.presentation === 'modal' || optionsForTransitionConfig.presentation === 'transparentModal' || (nextDescriptor === null || nextDescriptor === void 0 ? void 0 : nextDescriptor.options.presentation) === 'modal' || (nextDescriptor === null || nextDescriptor === void 0 ? void 0 : nextDescriptor.options.presentation) === 'transparentModal' || getIsModalPresentation(cardStyleInterpolator)) && Platform.OS === 'ios' && descriptor.options.header === undefined ? 'float' : 'screen';\n        var scene = {\n          route: route,\n          descriptor: _objectSpread(_objectSpread({}, descriptor), {}, {\n            options: _objectSpread(_objectSpread({}, descriptor.options), {}, {\n              animationEnabled: animationEnabled,\n              cardOverlayEnabled: cardOverlayEnabled,\n              cardStyleInterpolator: cardStyleInterpolator,\n              gestureDirection: gestureDirection,\n              gestureEnabled: gestureEnabled,\n              headerStyleInterpolator: headerStyleInterpolator,\n              transitionSpec: transitionSpec,\n              headerMode: headerMode\n            })\n          }),\n          progress: {\n            current: getProgressFromGesture(currentGesture, state.layout, descriptor),\n            next: nextGesture && (nextDescriptor === null || nextDescriptor === void 0 ? void 0 : nextDescriptor.options.presentation) !== 'transparentModal' ? getProgressFromGesture(nextGesture, state.layout, nextDescriptor) : undefined,\n            previous: previousGesture ? getProgressFromGesture(previousGesture, state.layout, previousDescriptor) : undefined\n          },\n          __memo: [state.layout, descriptor, nextDescriptor, previousDescriptor, currentGesture, nextGesture, previousGesture]\n        };\n\n        if (oldScene && scene.__memo.every(function (it, i) {\n          return oldScene.__memo[i] === it;\n        })) {\n          return oldScene;\n        }\n\n        return scene;\n      });\n      return {\n        routes: props.routes,\n        scenes: scenes,\n        gestures: gestures,\n        descriptors: props.descriptors,\n        headerHeights: getHeaderHeights(scenes, props.insets, props.isParentHeaderShown, props.isParentModal, state.layout, state.headerHeights)\n      };\n    }\n  }]);\n\n  return CardStack;\n}(React.Component);\n\nexport { CardStack as default };\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  absolute: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0\n  },\n  floating: {\n    zIndex: 1\n  }\n});","map":{"version":3,"mappings":"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","names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","Background","getDefaultHeaderHeight","SafeAreaProviderCompat","Color","React","forModalPresentationIOS","forNoAnimation","forNoAnimationCard","DefaultTransition","ModalFadeTransition","ModalTransition","getDistanceForDirection","MaybeScreen","MaybeScreenContainer","getIsModalPresentation","CardContainer","EPSILON","STATE_INACTIVE","STATE_TRANSITIONING_OR_BELOW_TOP","STATE_ON_TOP","FALLBACK_DESCRIPTOR","freeze","options","getInterpolationIndex","scenes","index","cardStyleInterpolator","descriptor","interpolationIndex","i","_scenes$i","cardStyleInterpolatorCurrent","getIsModal","scene","isParentModal","isModalPresentation","isModal","getHeaderHeights","insets","isParentHeaderShown","layout","previous","reduce","acc","curr","headerStatusBarHeight","top","headerStyle","style","StyleSheet","flatten","height","route","getDistanceFromOptions","presentation","gestureDirection","getProgressFromGesture","gesture","distance","width","Math","max","interpolate","inputRange","outputRange","CardStack","_props","e","nativeEvent","setState","state","props","headerHeights","_ref","_ref2","previousHeight","routes","_ref3","getPreviousRoute","previousRoute","previousScene","find","undefined","gestures","initialMetrics","frame","descriptors","closingRouteKeys","onOpenRoute","onCloseRoute","renderHeader","renderScene","onTransitionStart","onTransitionEnd","onGestureStart","onGestureEnd","onGestureCancel","detachInactiveScreens","Platform","OS","focusedRoute","focusedHeaderHeight","isFloatHeaderAbsolute","slice","some","_scene$descriptor$opt","headerMode","headerTransparent","headerShown","activeScreensLimit","length","detachPreviousScreen","map","lastIndexOf","floatingHeader","createElement","Fragment","mode","getPreviousScene","getFocusedRoute","onContentHeightChange","handleHeaderLayout","styles","floating","absolute","enabled","container","onLayout","handleLayout","self","_scenes","_scenes2","focused","isScreenActive","sceneForActivity","outputValue","progress","current","extrapolate","headerTintColor","safeAreaInsetTop","safeAreaInsetRight","right","safeAreaInsetBottom","bottom","safeAreaInsetLeft","left","headerHeight","headerBackgroundColor","backgroundColor","headerDarkContent","isDark","isNextScreenTransparent","detachCurrentScreen","absoluteFill","active","pointerEvents","modal","closing","includes","onHeaderHeightChange","hasAbsoluteFloatHeader","animationEnabled","Animated","Value","openingRouteKeys","_descriptor$options$h","nextRoute","oldScene","currentGesture","previousGesture","nextGesture","nextDescriptor","previousDescriptor","optionsForTransitionConfig","defaultTransitionPreset","gestureEnabled","transitionSpec","headerStyleInterpolator","cardOverlayEnabled","header","next","__memo","every","it","Component","create","flex","position","zIndex"],"sources":["C:/Users/lance/OneDrive/Documents/GitHub/HuntersMedia/code/node_modules/@react-navigation/stack/lib/module/views/Stack/CardStack.js"],"sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nimport { Background, getDefaultHeaderHeight, SafeAreaProviderCompat } from '@react-navigation/elements';\r\nimport Color from 'color';\r\nimport * as React from 'react';\r\nimport { Animated, Platform, StyleSheet } from 'react-native';\r\nimport { forModalPresentationIOS, forNoAnimation as forNoAnimationCard } from '../../TransitionConfigs/CardStyleInterpolators';\r\nimport { DefaultTransition, ModalFadeTransition, ModalTransition } from '../../TransitionConfigs/TransitionPresets';\r\nimport getDistanceForDirection from '../../utils/getDistanceForDirection';\r\nimport { MaybeScreen, MaybeScreenContainer } from '../Screens';\r\nimport { getIsModalPresentation } from './Card';\r\nimport CardContainer from './CardContainer';\r\nconst EPSILON = 0.01;\r\nconst STATE_INACTIVE = 0;\r\nconst STATE_TRANSITIONING_OR_BELOW_TOP = 1;\r\nconst STATE_ON_TOP = 2;\r\nconst FALLBACK_DESCRIPTOR = Object.freeze({\r\n  options: {}\r\n});\r\n\r\nconst getInterpolationIndex = (scenes, index) => {\r\n  const {\r\n    cardStyleInterpolator\r\n  } = scenes[index].descriptor.options; // Start from current card and count backwards the number of cards with same interpolation\r\n\r\n  let interpolationIndex = 0;\r\n\r\n  for (let i = index - 1; i >= 0; i--) {\r\n    var _scenes$i;\r\n\r\n    const cardStyleInterpolatorCurrent = (_scenes$i = scenes[i]) === null || _scenes$i === void 0 ? void 0 : _scenes$i.descriptor.options.cardStyleInterpolator;\r\n\r\n    if (cardStyleInterpolatorCurrent !== cardStyleInterpolator) {\r\n      break;\r\n    }\r\n\r\n    interpolationIndex++;\r\n  }\r\n\r\n  return interpolationIndex;\r\n};\r\n\r\nconst getIsModal = (scene, interpolationIndex, isParentModal) => {\r\n  if (isParentModal) {\r\n    return true;\r\n  }\r\n\r\n  const {\r\n    cardStyleInterpolator\r\n  } = scene.descriptor.options;\r\n  const isModalPresentation = getIsModalPresentation(cardStyleInterpolator);\r\n  const isModal = isModalPresentation && interpolationIndex !== 0;\r\n  return isModal;\r\n};\r\n\r\nconst getHeaderHeights = (scenes, insets, isParentHeaderShown, isParentModal, layout, previous) => {\r\n  return scenes.reduce((acc, curr, index) => {\r\n    const {\r\n      headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top,\r\n      headerStyle\r\n    } = curr.descriptor.options;\r\n    const style = StyleSheet.flatten(headerStyle || {});\r\n    const height = typeof style.height === 'number' ? style.height : previous[curr.route.key];\r\n    const interpolationIndex = getInterpolationIndex(scenes, index);\r\n    const isModal = getIsModal(curr, interpolationIndex, isParentModal);\r\n    acc[curr.route.key] = typeof height === 'number' ? height : getDefaultHeaderHeight(layout, isModal, headerStatusBarHeight);\r\n    return acc;\r\n  }, {});\r\n};\r\n\r\nconst getDistanceFromOptions = (layout, descriptor) => {\r\n  const {\r\n    presentation,\r\n    gestureDirection = presentation === 'modal' ? ModalTransition.gestureDirection : DefaultTransition.gestureDirection\r\n  } = (descriptor === null || descriptor === void 0 ? void 0 : descriptor.options) || {};\r\n  return getDistanceForDirection(layout, gestureDirection);\r\n};\r\n\r\nconst getProgressFromGesture = (gesture, layout, descriptor) => {\r\n  const distance = getDistanceFromOptions({\r\n    // Make sure that we have a non-zero distance, otherwise there will be incorrect progress\r\n    // This causes blank screen on web if it was previously inside container with display: none\r\n    width: Math.max(1, layout.width),\r\n    height: Math.max(1, layout.height)\r\n  }, descriptor);\r\n\r\n  if (distance > 0) {\r\n    return gesture.interpolate({\r\n      inputRange: [0, distance],\r\n      outputRange: [1, 0]\r\n    });\r\n  }\r\n\r\n  return gesture.interpolate({\r\n    inputRange: [distance, 0],\r\n    outputRange: [0, 1]\r\n  });\r\n};\r\n\r\nexport default class CardStack extends React.Component {\r\n  static getDerivedStateFromProps(props, state) {\r\n    if (props.routes === state.routes && props.descriptors === state.descriptors) {\r\n      return null;\r\n    }\r\n\r\n    const gestures = props.routes.reduce((acc, curr) => {\r\n      const descriptor = props.descriptors[curr.key];\r\n      const {\r\n        animationEnabled\r\n      } = (descriptor === null || descriptor === void 0 ? void 0 : descriptor.options) || {};\r\n      acc[curr.key] = state.gestures[curr.key] || new Animated.Value(props.openingRouteKeys.includes(curr.key) && animationEnabled !== false ? getDistanceFromOptions(state.layout, descriptor) : 0);\r\n      return acc;\r\n    }, {});\r\n    const scenes = props.routes.map((route, index, self) => {\r\n      var _descriptor$options$h;\r\n\r\n      const previousRoute = self[index - 1];\r\n      const nextRoute = self[index + 1];\r\n      const oldScene = state.scenes[index];\r\n      const currentGesture = gestures[route.key];\r\n      const previousGesture = previousRoute ? gestures[previousRoute.key] : undefined;\r\n      const nextGesture = nextRoute ? gestures[nextRoute.key] : undefined;\r\n      const descriptor = props.descriptors[route.key] || state.descriptors[route.key] || (oldScene ? oldScene.descriptor : FALLBACK_DESCRIPTOR);\r\n      const nextDescriptor = props.descriptors[nextRoute === null || nextRoute === void 0 ? void 0 : nextRoute.key] || state.descriptors[nextRoute === null || nextRoute === void 0 ? void 0 : nextRoute.key];\r\n      const previousDescriptor = props.descriptors[previousRoute === null || previousRoute === void 0 ? void 0 : previousRoute.key] || state.descriptors[previousRoute === null || previousRoute === void 0 ? void 0 : previousRoute.key]; // When a screen is not the last, it should use next screen's transition config\r\n      // Many transitions also animate the previous screen, so using 2 different transitions doesn't look right\r\n      // For example combining a slide and a modal transition would look wrong otherwise\r\n      // With this approach, combining different transition styles in the same navigator mostly looks right\r\n      // This will still be broken when 2 transitions have different idle state (e.g. modal presentation),\r\n      // but majority of the transitions look alright\r\n\r\n      const optionsForTransitionConfig = index !== self.length - 1 && nextDescriptor && nextDescriptor.options.presentation !== 'transparentModal' ? nextDescriptor.options : descriptor.options;\r\n      let defaultTransitionPreset = optionsForTransitionConfig.presentation === 'modal' ? ModalTransition : optionsForTransitionConfig.presentation === 'transparentModal' ? ModalFadeTransition : DefaultTransition;\r\n      const {\r\n        animationEnabled = Platform.OS !== 'web' && Platform.OS !== 'windows' && Platform.OS !== 'macos',\r\n        gestureEnabled = Platform.OS === 'ios' && animationEnabled,\r\n        gestureDirection = defaultTransitionPreset.gestureDirection,\r\n        transitionSpec = defaultTransitionPreset.transitionSpec,\r\n        cardStyleInterpolator = animationEnabled === false ? forNoAnimationCard : defaultTransitionPreset.cardStyleInterpolator,\r\n        headerStyleInterpolator = defaultTransitionPreset.headerStyleInterpolator,\r\n        cardOverlayEnabled = Platform.OS !== 'ios' && optionsForTransitionConfig.presentation !== 'transparentModal' || getIsModalPresentation(cardStyleInterpolator)\r\n      } = optionsForTransitionConfig;\r\n      const headerMode = (_descriptor$options$h = descriptor.options.headerMode) !== null && _descriptor$options$h !== void 0 ? _descriptor$options$h : !(optionsForTransitionConfig.presentation === 'modal' || optionsForTransitionConfig.presentation === 'transparentModal' || (nextDescriptor === null || nextDescriptor === void 0 ? void 0 : nextDescriptor.options.presentation) === 'modal' || (nextDescriptor === null || nextDescriptor === void 0 ? void 0 : nextDescriptor.options.presentation) === 'transparentModal' || getIsModalPresentation(cardStyleInterpolator)) && Platform.OS === 'ios' && descriptor.options.header === undefined ? 'float' : 'screen';\r\n      const scene = {\r\n        route,\r\n        descriptor: { ...descriptor,\r\n          options: { ...descriptor.options,\r\n            animationEnabled,\r\n            cardOverlayEnabled,\r\n            cardStyleInterpolator,\r\n            gestureDirection,\r\n            gestureEnabled,\r\n            headerStyleInterpolator,\r\n            transitionSpec,\r\n            headerMode\r\n          }\r\n        },\r\n        progress: {\r\n          current: getProgressFromGesture(currentGesture, state.layout, descriptor),\r\n          next: nextGesture && (nextDescriptor === null || nextDescriptor === void 0 ? void 0 : nextDescriptor.options.presentation) !== 'transparentModal' ? getProgressFromGesture(nextGesture, state.layout, nextDescriptor) : undefined,\r\n          previous: previousGesture ? getProgressFromGesture(previousGesture, state.layout, previousDescriptor) : undefined\r\n        },\r\n        __memo: [state.layout, descriptor, nextDescriptor, previousDescriptor, currentGesture, nextGesture, previousGesture]\r\n      };\r\n\r\n      if (oldScene && scene.__memo.every((it, i) => {\r\n        // @ts-expect-error: we haven't added __memo to the annotation to prevent usage elsewhere\r\n        return oldScene.__memo[i] === it;\r\n      })) {\r\n        return oldScene;\r\n      }\r\n\r\n      return scene;\r\n    });\r\n    return {\r\n      routes: props.routes,\r\n      scenes,\r\n      gestures,\r\n      descriptors: props.descriptors,\r\n      headerHeights: getHeaderHeights(scenes, props.insets, props.isParentHeaderShown, props.isParentModal, state.layout, state.headerHeights)\r\n    };\r\n  }\r\n\r\n  constructor(_props) {\r\n    super(_props);\r\n\r\n    _defineProperty(this, \"handleLayout\", e => {\r\n      const {\r\n        height,\r\n        width\r\n      } = e.nativeEvent.layout;\r\n      const layout = {\r\n        width,\r\n        height\r\n      };\r\n      this.setState((state, props) => {\r\n        if (height === state.layout.height && width === state.layout.width) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          layout,\r\n          headerHeights: getHeaderHeights(state.scenes, props.insets, props.isParentHeaderShown, props.isParentModal, layout, state.headerHeights)\r\n        };\r\n      });\r\n    });\r\n\r\n    _defineProperty(this, \"handleHeaderLayout\", _ref => {\r\n      let {\r\n        route,\r\n        height\r\n      } = _ref;\r\n      this.setState(_ref2 => {\r\n        let {\r\n          headerHeights\r\n        } = _ref2;\r\n        const previousHeight = headerHeights[route.key];\r\n\r\n        if (previousHeight === height) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          headerHeights: { ...headerHeights,\r\n            [route.key]: height\r\n          }\r\n        };\r\n      });\r\n    });\r\n\r\n    _defineProperty(this, \"getFocusedRoute\", () => {\r\n      const {\r\n        state\r\n      } = this.props;\r\n      return state.routes[state.index];\r\n    });\r\n\r\n    _defineProperty(this, \"getPreviousScene\", _ref3 => {\r\n      let {\r\n        route\r\n      } = _ref3;\r\n      const {\r\n        getPreviousRoute\r\n      } = this.props;\r\n      const {\r\n        scenes\r\n      } = this.state;\r\n      const previousRoute = getPreviousRoute({\r\n        route\r\n      });\r\n\r\n      if (previousRoute) {\r\n        const previousScene = scenes.find(scene => scene.descriptor.route.key === previousRoute.key);\r\n        return previousScene;\r\n      }\r\n\r\n      return undefined;\r\n    });\r\n\r\n    this.state = {\r\n      routes: [],\r\n      scenes: [],\r\n      gestures: {},\r\n      layout: SafeAreaProviderCompat.initialMetrics.frame,\r\n      descriptors: this.props.descriptors,\r\n      // Used when card's header is null and mode is float to make transition\r\n      // between screens with headers and those without headers smooth.\r\n      // This is not a great heuristic here. We don't know synchronously\r\n      // on mount what the header height is so we have just used the most\r\n      // common cases here.\r\n      headerHeights: {}\r\n    };\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      insets,\r\n      state,\r\n      routes,\r\n      closingRouteKeys,\r\n      onOpenRoute,\r\n      onCloseRoute,\r\n      renderHeader,\r\n      renderScene,\r\n      isParentHeaderShown,\r\n      isParentModal,\r\n      onTransitionStart,\r\n      onTransitionEnd,\r\n      onGestureStart,\r\n      onGestureEnd,\r\n      onGestureCancel,\r\n      detachInactiveScreens = Platform.OS === 'web' || Platform.OS === 'android' || Platform.OS === 'ios'\r\n    } = this.props;\r\n    const {\r\n      scenes,\r\n      layout,\r\n      gestures,\r\n      headerHeights\r\n    } = this.state;\r\n    const focusedRoute = state.routes[state.index];\r\n    const focusedHeaderHeight = headerHeights[focusedRoute.key];\r\n    const isFloatHeaderAbsolute = this.state.scenes.slice(-2).some(scene => {\r\n      var _scene$descriptor$opt;\r\n\r\n      const options = (_scene$descriptor$opt = scene.descriptor.options) !== null && _scene$descriptor$opt !== void 0 ? _scene$descriptor$opt : {};\r\n      const {\r\n        headerMode,\r\n        headerTransparent,\r\n        headerShown = true\r\n      } = options;\r\n\r\n      if (headerTransparent || headerShown === false || headerMode === 'screen') {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    });\r\n    let activeScreensLimit = 1;\r\n\r\n    for (let i = scenes.length - 1; i >= 0; i--) {\r\n      const {\r\n        options\r\n      } = scenes[i].descriptor;\r\n      const {\r\n        // By default, we don't want to detach the previous screen of the active one for modals\r\n        detachPreviousScreen = options.presentation === 'transparentModal' ? false : getIsModalPresentation(options.cardStyleInterpolator) ? i !== scenes.map(scene => scene.descriptor.options.cardStyleInterpolator).lastIndexOf(forModalPresentationIOS) : true\r\n      } = options;\r\n\r\n      if (detachPreviousScreen === false) {\r\n        activeScreensLimit++;\r\n      } else {\r\n        // Check at least last 2 screens before stopping\r\n        // This will make sure that screen isn't detached when another screen is animating on top of the transparent one\r\n        // For example, (Opaque -> Transparent -> Opaque)\r\n        if (i <= scenes.length - 2) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    const floatingHeader = /*#__PURE__*/React.createElement(React.Fragment, {\r\n      key: \"header\"\r\n    }, renderHeader({\r\n      mode: 'float',\r\n      layout,\r\n      scenes,\r\n      getPreviousScene: this.getPreviousScene,\r\n      getFocusedRoute: this.getFocusedRoute,\r\n      onContentHeightChange: this.handleHeaderLayout,\r\n      style: [styles.floating, isFloatHeaderAbsolute && [// Without this, the header buttons won't be touchable on Android when headerTransparent: true\r\n      {\r\n        height: focusedHeaderHeight\r\n      }, styles.absolute]]\r\n    }));\r\n    return /*#__PURE__*/React.createElement(Background, null, isFloatHeaderAbsolute ? null : floatingHeader, /*#__PURE__*/React.createElement(MaybeScreenContainer, {\r\n      enabled: detachInactiveScreens,\r\n      style: styles.container,\r\n      onLayout: this.handleLayout\r\n    }, routes.map((route, index, self) => {\r\n      var _scenes, _scenes2;\r\n\r\n      const focused = focusedRoute.key === route.key;\r\n      const gesture = gestures[route.key];\r\n      const scene = scenes[index]; // For the screens that shouldn't be active, the value is 0\r\n      // For those that should be active, but are not the top screen, the value is 1\r\n      // For those on top of the stack and with interaction enabled, the value is 2\r\n      // For the old implementation, it stays the same it was\r\n\r\n      let isScreenActive = 1;\r\n\r\n      if (index < self.length - activeScreensLimit - 1) {\r\n        // screen should be inactive because it is too deep in the stack\r\n        isScreenActive = STATE_INACTIVE;\r\n      } else {\r\n        const sceneForActivity = scenes[self.length - 1];\r\n        const outputValue = index === self.length - 1 ? STATE_ON_TOP // the screen is on top after the transition\r\n        : index >= self.length - activeScreensLimit ? STATE_TRANSITIONING_OR_BELOW_TOP // the screen should stay active after the transition, it is not on top but is in activeLimit\r\n        : STATE_INACTIVE; // the screen should be active only during the transition, it is at the edge of activeLimit\r\n\r\n        isScreenActive = sceneForActivity ? sceneForActivity.progress.current.interpolate({\r\n          inputRange: [0, 1 - EPSILON, 1],\r\n          outputRange: [1, 1, outputValue],\r\n          extrapolate: 'clamp'\r\n        }) : STATE_TRANSITIONING_OR_BELOW_TOP;\r\n      }\r\n\r\n      const {\r\n        headerShown = true,\r\n        headerTransparent,\r\n        headerStyle,\r\n        headerTintColor\r\n      } = scene.descriptor.options;\r\n      const safeAreaInsetTop = insets.top;\r\n      const safeAreaInsetRight = insets.right;\r\n      const safeAreaInsetBottom = insets.bottom;\r\n      const safeAreaInsetLeft = insets.left;\r\n      const headerHeight = headerShown !== false ? headerHeights[route.key] : 0;\r\n      const {\r\n        backgroundColor: headerBackgroundColor\r\n      } = StyleSheet.flatten(headerStyle) || {};\r\n      let headerDarkContent;\r\n\r\n      if (headerShown) {\r\n        if (typeof headerTintColor === 'string') {\r\n          headerDarkContent = Color(headerTintColor).isDark();\r\n        } else if (typeof headerBackgroundColor === 'string') {\r\n          headerDarkContent = !Color(headerBackgroundColor).isDark();\r\n        }\r\n      } // Start from current card and count backwards the number of cards with same interpolation\r\n\r\n\r\n      const interpolationIndex = getInterpolationIndex(scenes, index);\r\n      const isModal = getIsModal(scene, interpolationIndex, isParentModal);\r\n      const isNextScreenTransparent = ((_scenes = scenes[index + 1]) === null || _scenes === void 0 ? void 0 : _scenes.descriptor.options.presentation) === 'transparentModal';\r\n      const detachCurrentScreen = ((_scenes2 = scenes[index + 1]) === null || _scenes2 === void 0 ? void 0 : _scenes2.descriptor.options.detachPreviousScreen) !== false;\r\n      return /*#__PURE__*/React.createElement(MaybeScreen, {\r\n        key: route.key,\r\n        style: StyleSheet.absoluteFill,\r\n        enabled: detachInactiveScreens,\r\n        active: isScreenActive,\r\n        pointerEvents: \"box-none\"\r\n      }, /*#__PURE__*/React.createElement(CardContainer, {\r\n        index: index,\r\n        interpolationIndex: interpolationIndex,\r\n        modal: isModal,\r\n        active: index === self.length - 1,\r\n        focused: focused,\r\n        closing: closingRouteKeys.includes(route.key),\r\n        layout: layout,\r\n        gesture: gesture,\r\n        scene: scene,\r\n        safeAreaInsetTop: safeAreaInsetTop,\r\n        safeAreaInsetRight: safeAreaInsetRight,\r\n        safeAreaInsetBottom: safeAreaInsetBottom,\r\n        safeAreaInsetLeft: safeAreaInsetLeft,\r\n        onGestureStart: onGestureStart,\r\n        onGestureCancel: onGestureCancel,\r\n        onGestureEnd: onGestureEnd,\r\n        headerHeight: headerHeight,\r\n        isParentHeaderShown: isParentHeaderShown,\r\n        onHeaderHeightChange: this.handleHeaderLayout,\r\n        getPreviousScene: this.getPreviousScene,\r\n        getFocusedRoute: this.getFocusedRoute,\r\n        headerDarkContent: headerDarkContent,\r\n        hasAbsoluteFloatHeader: isFloatHeaderAbsolute && !headerTransparent,\r\n        renderHeader: renderHeader,\r\n        renderScene: renderScene,\r\n        onOpenRoute: onOpenRoute,\r\n        onCloseRoute: onCloseRoute,\r\n        onTransitionStart: onTransitionStart,\r\n        onTransitionEnd: onTransitionEnd,\r\n        isNextScreenTransparent: isNextScreenTransparent,\r\n        detachCurrentScreen: detachCurrentScreen\r\n      }));\r\n    })), isFloatHeaderAbsolute ? floatingHeader : null);\r\n  }\r\n\r\n}\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1\r\n  },\r\n  absolute: {\r\n    position: 'absolute',\r\n    top: 0,\r\n    left: 0,\r\n    right: 0\r\n  },\r\n  floating: {\r\n    zIndex: 1\r\n  }\r\n});\r\n//# sourceMappingURL=CardStack.js.map"]},"metadata":{},"sourceType":"module"}